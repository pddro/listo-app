import { useParams, useNavigate } from 'react-router-dom';
import { useEffect, useState, useCallback, useRef, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { Preferences } from '@capacitor/preferences';
import { Device } from '@capacitor/device';
import { useList } from '@/lib/hooks/useList';
import { useAI, ManipulatedItem } from '@/lib/hooks/useAI';
import { useRecentLists } from '@/lib/hooks/useRecentLists';
import { ListContainer } from '@/components/ListContainer';
import { NewItemInput } from '@/components/NewItemInput';
import { DictateButton } from '@/components/DictateButton';
import { isCategorizedResult } from '@/lib/hooks/useAI';
import { ThemeColors } from '@/lib/gemini';
import { API } from '@/lib/api';
import { useAppState } from '@/mobile/context/AppStateContext';
import { analytics } from '@/lib/analytics';

// Apply theme to CSS variables
function applyThemeToRoot(theme: ThemeColors | null) {
  const root = document.documentElement;
  if (theme) {
    root.style.setProperty('--primary', theme.primary);
    root.style.setProperty('--primary-dark', theme.primaryDark);
    root.style.setProperty('--primary-light', theme.primaryLight);
    root.style.setProperty('--primary-pale', theme.primaryPale);
    root.style.setProperty('--primary-glow', theme.primaryGlow);
    root.style.setProperty('--text-primary', theme.textPrimary);
    root.style.setProperty('--text-secondary', theme.textSecondary);
    root.style.setProperty('--text-muted', theme.textMuted);
    root.style.setProperty('--text-placeholder', theme.textPlaceholder);
    root.style.setProperty('--bg-primary', theme.bgPrimary);
    root.style.setProperty('--bg-secondary', theme.bgSecondary);
    root.style.setProperty('--bg-hover', theme.bgHover);
    root.style.setProperty('--border-light', theme.borderLight);
    root.style.setProperty('--border-medium', theme.borderMedium);
    root.style.setProperty('--error', theme.error);
  } else {
    root.style.removeProperty('--primary');
    root.style.removeProperty('--primary-dark');
    root.style.removeProperty('--primary-light');
    root.style.removeProperty('--primary-pale');
    root.style.removeProperty('--primary-glow');
    root.style.removeProperty('--text-primary');
    root.style.removeProperty('--text-secondary');
    root.style.removeProperty('--text-muted');
    root.style.removeProperty('--text-placeholder');
    root.style.removeProperty('--bg-primary');
    root.style.removeProperty('--bg-secondary');
    root.style.removeProperty('--bg-hover');
    root.style.removeProperty('--border-light');
    root.style.removeProperty('--border-medium');
    root.style.removeProperty('--error');
  }
}

interface ListPageProps {
  listId?: string;
}

export default function ListPage({ listId: listIdProp }: ListPageProps = {}) {
  const { t } = useTranslation();
  const params = useParams<{ listId: string }>();
  const listId = listIdProp || params.listId;
  const navigate = useNavigate();
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [editedTitle, setEditedTitle] = useState('');
  const [inputPrefillValue, setInputPrefillValue] = useState<string | undefined>(undefined);
  const [justAddedToMyLists, setJustAddedToMyLists] = useState(false);
  const [platform, setPlatform] = useState<'ios' | 'android' | 'web'>('web');
  const autoTitleTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const hasAutoGeneratedRef = useRef(false);
  const titleInputRef = useRef<HTMLInputElement>(null);

  // Get cached data for instant loading and home theme for back navigation
  const { getCachedList, updateCachedList, updateCachedItems, homeTheme } = useAppState();
  const cachedData = useMemo(() => listId ? getCachedList(listId) : null, [listId, getCachedList]);

  // Detect platform for safe area handling
  useEffect(() => {
    Device.getInfo().then(info => {
      setPlatform(info.platform as 'ios' | 'android' | 'web');
    });
  }, []);

  // Platform-specific safe area values (Android WebView doesn't support env())
  const safeAreaTop = platform === 'android' ? '36px' : 'env(safe-area-inset-top, 0px)';
  const safeAreaBottom = platform === 'android' ? '24px' : 'env(safe-area-inset-bottom, 0px)';

  // Callbacks to update cache when data changes
  const handleListChange = useCallback((updatedList: Parameters<typeof updateCachedList>[1]) => {
    if (listId) updateCachedList(listId, updatedList);
  }, [listId, updateCachedList]);

  const handleItemsChange = useCallback((updatedItems: Parameters<typeof updateCachedItems>[1]) => {
    if (listId) updateCachedItems(listId, updatedItems);
  }, [listId, updateCachedItems]);

  const {
    list,
    items,
    itemTree,
    loading,
    error,
    newItemId,
    newItemIds,
    completingItemIds,
    createList,
    updateTitle,
    updateTheme,
    updateLargeMode,
    addItem,
    addItems,
    insertItem,
    updateItem,
    toggleItem,
    deleteItem,
    reorderItems,
    moveToGroup,
    moveToRoot,
    indentItem,
    outdentItem,
    completeAll,
    uncompleteAll,
    clearCompleted,
    sortItems,
    ungroupAll,
    nukeItems,
    toggleEmojifyMode,
  } = useList(listId!, {
    initialList: cachedData?.list,
    initialItems: cachedData?.items,
    onListChange: handleListChange,
    onItemsChange: handleItemsChange,
  });

  const { manipulateList, generateItems } = useAI();
  const { lists: savedLists, addList: addSavedList, updateList: updateSavedList } = useRecentLists();

  // Check if this list is already saved
  const isListSaved = savedLists.some(savedList => savedList.id === listId);

  // Get saved list data for this list (for early theme application)
  const savedListData = savedLists.find(savedList => savedList.id === listId);

  // Apply partial theme immediately from saved list data (before full list loads)
  // This prevents the jarring theme change during loading
  useEffect(() => {
    if (savedListData?.themeColor || savedListData?.themeTextColor) {
      const root = document.documentElement;
      if (savedListData.themeColor) {
        root.style.setProperty('--bg-primary', savedListData.themeColor);
      }
      if (savedListData.themeTextColor) {
        root.style.setProperty('--primary', savedListData.themeTextColor);
      }
    }
  }, [savedListData?.themeColor, savedListData?.themeTextColor]);

  // Create list if it doesn't exist
  useEffect(() => {
    if (!loading && !list && !error) {
      createList();
    }
  }, [loading, list, error, createList]);

  // Auto-save new lists to "My Lists"
  useEffect(() => {
    if (list && listId && !isListSaved) {
      const createdAt = new Date(list.created_at).getTime();
      const now = Date.now();
      const isNewList = now - createdAt < 30000;

      if (isNewList) {
        // Auto-save newly created lists (bgPrimary for square, primary for text)
        addSavedList(listId, list.title || null, list.theme?.bgPrimary || null, list.theme?.primary || null);
      }
    }
  }, [list, listId, isListSaved, addSavedList]);

  // Update item counts in saved list whenever items change
  useEffect(() => {
    if (listId && isListSaved && items.length > 0) {
      const nonHeaderItems = items.filter(item => !item.content.startsWith('#'));
      const completedCount = nonHeaderItems.filter(item => item.completed).length;
      const itemCount = nonHeaderItems.length;
      updateSavedList(listId, { itemCount, completedCount });
    }
  }, [listId, isListSaved, items, updateSavedList]);

  // Sync theme colors to saved list when visiting (keeps homepage squares up to date)
  useEffect(() => {
    if (listId && isListSaved && list) {
      updateSavedList(listId, {
        themeColor: list.theme?.bgPrimary || null,
        themeTextColor: list.theme?.primary || null,
      });
    }
  }, [listId, isListSaved, list?.theme, updateSavedList]);

  // Auto-generate title after 3+ items
  useEffect(() => {
    if (autoTitleTimeoutRef.current) {
      clearTimeout(autoTitleTimeoutRef.current);
    }

    const nonHeaderItems = items.filter(item => !item.content.startsWith('#'));
    const shouldAutoGenerate =
      list &&
      !list.title &&
      nonHeaderItems.length >= 3 &&
      !hasAutoGeneratedRef.current;

    if (shouldAutoGenerate) {
      autoTitleTimeoutRef.current = setTimeout(async () => {
        try {
          const itemContents = items
            .filter(item => !item.completed && !item.content.startsWith('#'))
            .map(item => item.content);

          if (itemContents.length === 0) return;

          const response = await fetch(API.title, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ items: itemContents }),
          });

          if (response.ok) {
            const { title } = await response.json();
            if (!list.title) {
              hasAutoGeneratedRef.current = true;
              await updateTitle(title);
              if (listId) updateSavedList(listId, { title });
            }
          }
        } catch (err) {
          console.error('Auto-title generation failed:', err);
        }
      }, 2000);
    }

    return () => {
      if (autoTitleTimeoutRef.current) {
        clearTimeout(autoTitleTimeoutRef.current);
      }
    };
  }, [items, list, updateTitle, listId, updateSavedList]);

  // Apply theme
  const applyTheme = useCallback((theme: ThemeColors | null) => {
    const root = document.documentElement;
    if (theme) {
      root.style.setProperty('--primary', theme.primary);
      root.style.setProperty('--primary-dark', theme.primaryDark);
      root.style.setProperty('--primary-light', theme.primaryLight);
      root.style.setProperty('--primary-pale', theme.primaryPale);
      root.style.setProperty('--primary-glow', theme.primaryGlow);
      root.style.setProperty('--text-primary', theme.textPrimary);
      root.style.setProperty('--text-secondary', theme.textSecondary);
      root.style.setProperty('--text-muted', theme.textMuted);
      root.style.setProperty('--text-placeholder', theme.textPlaceholder);
      root.style.setProperty('--bg-primary', theme.bgPrimary);
      root.style.setProperty('--bg-secondary', theme.bgSecondary);
      root.style.setProperty('--bg-hover', theme.bgHover);
      root.style.setProperty('--border-light', theme.borderLight);
      root.style.setProperty('--border-medium', theme.borderMedium);
      root.style.setProperty('--error', theme.error);
    } else {
      root.style.removeProperty('--primary');
      root.style.removeProperty('--primary-dark');
      root.style.removeProperty('--primary-light');
      root.style.removeProperty('--primary-pale');
      root.style.removeProperty('--primary-glow');
      root.style.removeProperty('--text-primary');
      root.style.removeProperty('--text-secondary');
      root.style.removeProperty('--text-muted');
      root.style.removeProperty('--text-placeholder');
      root.style.removeProperty('--bg-primary');
      root.style.removeProperty('--bg-secondary');
      root.style.removeProperty('--bg-hover');
      root.style.removeProperty('--border-light');
      root.style.removeProperty('--border-medium');
      root.style.removeProperty('--error');
    }
  }, []);

  useEffect(() => {
    if (list) {
      applyTheme(list.theme);
    }
    return () => {
      applyTheme(null);
    };
  }, [list, applyTheme]);

  const handleThemeGenerate = async (description: string) => {
    const response = await fetch(API.theme, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ description }),
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Theme generation failed');
    }

    const { theme } = await response.json();
    applyTheme(theme);
    await updateTheme(theme);
    if (listId) updateSavedList(listId, { themeColor: theme.bgPrimary, themeTextColor: theme.primary });
  };

  const handleThemeReset = async () => {
    applyTheme(null);
    await updateTheme(null);
    if (listId) updateSavedList(listId, { themeColor: null, themeTextColor: null });
  };

  const emojifyText = async (text: string): Promise<string> => {
    try {
      const response = await fetch(API.emojify, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });
      if (response.ok) {
        const { emoji } = await response.json();
        return `${emoji} ${text}`;
      }
    } catch (err) {
      console.error('Emojify failed:', err);
    }
    return text;
  };

  const handleAddItem = async (content: string, parentId?: string | null) => {
    let finalContent = content;
    if (list?.emojify_mode && !content.startsWith('#') && !content.startsWith('--')) {
      finalContent = await emojifyText(content);
    }
    await addItem(finalContent, parentId);
    analytics.itemCreated('manual');
  };

  const handleAddItems = async (contents: string[], parentId?: string | null) => {
    let finalContents = contents;
    if (list?.emojify_mode) {
      finalContents = await Promise.all(
        contents.map(async (content) => {
          if (!content.startsWith('#') && !content.startsWith('--')) {
            return await emojifyText(content);
          }
          return content;
        })
      );
    }
    const result = await addItems(finalContents, parentId);
    // Track each item created via bulk add
    for (let i = 0; i < contents.length; i++) {
      analytics.itemCreated('bulk');
    }
    return result;
  };

  const handleShare = async () => {
    const url = `https://listo.to/${listId}`;
    const shareTitle = list?.title || 'My List';

    if (navigator.share) {
      try {
        await navigator.share({
          title: shareTitle,
          text: `Check out my list: ${shareTitle}`,
          url: url,
        });
        analytics.listShared('native_share');
      } catch (err) {
        if ((err as Error).name !== 'AbortError') {
          console.error('Share failed:', err);
        }
      }
    } else {
      await navigator.clipboard.writeText(url);
      analytics.listShared('copy_link');
    }
  };

  const handleBack = () => {
    // Apply home theme SYNCHRONOUSLY before navigation to prevent white flash
    applyThemeToRoot(homeTheme);
    navigate('/');
  };

  const handleTitleUpdate = async (title: string) => {
    await updateTitle(title);
    if (listId) updateSavedList(listId, { title });
  };

  const handleTitleTap = () => {
    setEditedTitle(list?.title || '');
    setIsEditingTitle(true);
    setTimeout(() => titleInputRef.current?.focus(), 50);
  };

  const handleTitleBlur = async () => {
    setIsEditingTitle(false);
    const trimmed = editedTitle.trim();
    if (trimmed !== (list?.title || '')) {
      await handleTitleUpdate(trimmed || '');
    }
  };

  const handleTitleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      titleInputRef.current?.blur();
    }
  };

  const handleAddToMyLists = () => {
    if (listId) {
      addSavedList(listId, list?.title || null, list?.theme?.bgPrimary || null, list?.theme?.primary || null);
      setJustAddedToMyLists(true);
      setTimeout(() => setJustAddedToMyLists(false), 2000);
    }
  };

  const handleGenerateTitle = async () => {
    const itemContents = items
      .filter(item => !item.completed && !item.content.startsWith('#'))
      .map(item => item.content);

    if (itemContents.length === 0) return;

    try {
      const response = await fetch(API.title, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items: itemContents }),
      });

      if (response.ok) {
        const { title } = await response.json();
        await updateTitle(title);
        if (listId) updateSavedList(listId, { title });
      }
    } catch (err) {
      console.error('Title generation failed:', err);
    }
  };

  const handleManipulateList = async (instruction: string) => {
    const incompleteItems = items.filter(item => !item.completed);

    if (incompleteItems.length === 0) {
      throw new Error('No items to reorganize');
    }

    const manipulatedItems = await manipulateList(incompleteItems, instruction);

    const newItems = manipulatedItems.filter(item => item.id.startsWith('new_'));
    const existingItems = manipulatedItems.filter(item => !item.id.startsWith('new_'));

    const idMapping: Record<string, string> = {};

    for (const newItem of newItems) {
      const data = await insertItem({
        content: newItem.content,
        parent_id: null,
        position: newItem.position,
        completed: false,
      });

      if (data) {
        idMapping[newItem.id] = data.id;
      }
    }

    for (const manipulatedItem of existingItems) {
      let realParentId = manipulatedItem.parent_id;
      if (realParentId && idMapping[realParentId]) {
        realParentId = idMapping[realParentId];
      }

      await updateItem(manipulatedItem.id, {
        content: manipulatedItem.content,
        position: manipulatedItem.position,
        parent_id: realParentId,
      });
    }
  };

  const handleDictation = async (transcription: string) => {
    if (!transcription.trim()) return;

    try {
      const result = await generateItems(transcription);

      if (result.length > 0) {
        if (isCategorizedResult(result)) {
          await handleCategorizedGenerate(result, 'dictation');
        } else {
          await addItems(result);
          // Track each item created via dictation
          for (let i = 0; i < result.length; i++) {
            analytics.itemCreated('dictation');
          }
        }
      }
    } catch (err) {
      console.error('Failed to process dictation:', err);
    }
  };

  const handleCategorizedGenerate = async (generatedItems: ManipulatedItem[], method: 'ai' | 'dictation' = 'ai') => {
    if (generatedItems.length === 0) return;

    const idMapping: Record<string, string> = {};

    const headers = generatedItems.filter(item => !item.parent_id);
    for (const header of headers) {
      const data = await insertItem({
        content: header.content,
        parent_id: null,
        position: header.position,
        completed: false,
      });

      if (data) {
        idMapping[header.id] = data.id;
      }
    }

    const children = generatedItems.filter(item => item.parent_id);
    for (const child of children) {
      const realParentId = child.parent_id ? idMapping[child.parent_id] : null;

      await insertItem({
        content: child.content,
        parent_id: realParentId,
        position: child.position,
        completed: false,
      });
    }

    // Track each item created (headers + children)
    for (let i = 0; i < generatedItems.length; i++) {
      analytics.itemCreated(method);
    }
  };

  if (loading) {
    // Show themed skeleton loading based on saved list data
    const skeletonCount = savedListData?.itemCount || 5;
    return (
      <div
        style={{
          position: 'relative',
          height: '100vh',
          backgroundColor: 'var(--bg-primary)',
        }}
      >
        {/* Skeleton header */}
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            zIndex: 30,
            backgroundColor: 'var(--bg-primary)',
            paddingTop: safeAreaTop,
          }}
        >
          <div
            className="flex items-center justify-between"
            style={{ height: '44px', padding: '0 16px' }}
          >
            <div
              className="rounded"
              style={{ width: '60px', height: '20px', backgroundColor: 'var(--primary)', opacity: 0.2 }}
            />
            <div
              className="rounded"
              style={{ width: '100px', height: '20px', backgroundColor: 'var(--primary)', opacity: 0.15 }}
            />
            <div
              className="rounded"
              style={{ width: '24px', height: '24px', backgroundColor: 'var(--primary)', opacity: 0.2 }}
            />
          </div>
          {/* Skeleton input */}
          <div style={{ padding: '8px 16px 12px' }}>
            <div
              className="rounded-xl"
              style={{ height: '48px', backgroundColor: 'var(--primary)', opacity: 0.08 }}
            />
          </div>
        </div>

        {/* Skeleton items */}
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            overflowY: 'auto',
            paddingTop: `calc(${safeAreaTop} + 120px)`,
            paddingLeft: '16px',
            paddingRight: '16px',
          }}
        >
          {Array.from({ length: Math.min(skeletonCount, 8) }).map((_, i) => (
            <div
              key={i}
              className="flex items-center gap-3"
              style={{
                padding: '12px 0',
                opacity: 1 - (i * 0.1),
              }}
            >
              <div
                className="rounded-md flex-shrink-0"
                style={{
                  width: '28px',
                  height: '28px',
                  backgroundColor: 'var(--primary)',
                  opacity: 0.15,
                }}
              />
              <div
                className="rounded flex-1"
                style={{
                  height: '20px',
                  backgroundColor: 'var(--primary)',
                  opacity: 0.1,
                  width: `${60 + Math.random() * 30}%`,
                }}
              />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div
        className="min-h-screen flex flex-col items-center justify-center px-6"
        style={{
          backgroundColor: 'var(--bg-primary)',
          paddingTop: safeAreaTop,
        }}
      >
        <div style={{ color: 'var(--error)', marginBottom: '16px' }}>{error}</div>
        <button
          onClick={handleBack}
          className="px-4 py-2 rounded-lg"
          style={{ backgroundColor: 'var(--primary)', color: 'white' }}
        >
          {t('mobile.goHome')}
        </button>
      </div>
    );
  }

  const displayTitle = list?.title || t('home.untitledList');

  return (
    <div
      style={{
        position: 'relative',
        height: '100vh',
        backgroundColor: 'var(--bg-primary)',
      }}
    >
      {/* iOS-style Navigation Header - Glass effect overlay */}
      <div
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          zIndex: 30,
          backdropFilter: 'blur(20px) saturate(180%)',
          WebkitBackdropFilter: 'blur(20px) saturate(180%)',
          paddingTop: safeAreaTop,
          borderBottom: '1px solid var(--border-light)',
        }}
      >
        {/* Theme color overlay */}
        <div
          style={{
            position: 'absolute',
            inset: 0,
            backgroundColor: 'var(--bg-primary)',
            opacity: 0.35,
            pointerEvents: 'none',
          }}
        />
        <div
          className="flex items-center justify-between"
          style={{
            height: '44px',
            paddingLeft: '4px',
            paddingRight: '8px',
          }}
        >
          {/* Back Button */}
          <button
            onClick={handleBack}
            className="flex items-center gap-0.5 active:opacity-60"
            style={{
              color: 'var(--primary)',
              fontSize: '17px',
              padding: '8px 4px',
              marginLeft: '-4px',
            }}
          >
            <svg
              className="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              style={{ strokeWidth: 2.5 }}
            >
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" />
            </svg>
            <span>{t('mobile.lists')}</span>
          </button>

          {/* Title (tappable to edit) */}
          <div
            className="flex-1 mx-3 flex justify-center"
            style={{ minWidth: 0 }}
          >
            {isEditingTitle ? (
              <input
                ref={titleInputRef}
                type="text"
                value={editedTitle}
                onChange={(e) => setEditedTitle(e.target.value)}
                onBlur={handleTitleBlur}
                onKeyDown={handleTitleKeyDown}
                className="w-full text-center bg-transparent outline-none"
                style={{
                  fontSize: '17px',
                  fontWeight: 600,
                  color: 'var(--text-primary)',
                }}
                placeholder={t('mobile.listTitle')}
              />
            ) : (
              <button
                onClick={handleTitleTap}
                className="truncate text-center active:opacity-60"
                style={{
                  fontSize: '17px',
                  fontWeight: 600,
                  color: 'var(--text-primary)',
                  maxWidth: '100%',
                }}
              >
                {displayTitle}
              </button>
            )}
          </div>

          {/* Share Button */}
          <button
            onClick={handleShare}
            className="active:opacity-60"
            style={{
              color: 'var(--primary)',
              padding: '8px',
            }}
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
              />
            </svg>
          </button>
        </div>

        {/* Input Field - Inside Header */}
        <div style={{ padding: '4px 8px 4px 8px' }}>
          <NewItemInput
            onAdd={handleAddItem}
            onBulkAdd={handleAddItems}
            onAIGenerate={generateItems}
            onAICategorizedGenerate={handleCategorizedGenerate}
            onAIManipulate={handleManipulateList}
            onThemeGenerate={handleThemeGenerate}
            onThemeReset={list?.theme ? handleThemeReset : undefined}
            onCompleteAll={completeAll}
            onUncompleteAll={uncompleteAll}
            onSetLargeMode={updateLargeMode}
            onClearCompleted={clearCompleted}
            onSort={sortItems}
            onUngroupAll={ungroupAll}
            onToggleEmojify={toggleEmojifyMode}
            onNuke={nukeItems}
            onGenerateTitle={handleGenerateTitle}
            prefillValue={inputPrefillValue}
            onPrefillConsumed={() => setInputPrefillValue(undefined)}
            hasTheme={!!list?.theme}
            largeMode={list?.large_mode || false}
            emojifyMode={list?.emojify_mode || false}
            autoFocus={items.length < 10}
          />
        </div>
      </div>

      {/* Scrollable Content Area - extends behind header for glass effect */}
      <div
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          overflowY: 'scroll',
          WebkitOverflowScrolling: 'touch',
          paddingTop: `calc(${safeAreaTop} + 121px)`,
        }}
      >
        {/* Add to My Lists Banner (for received lists) */}
      {!isListSaved && !justAddedToMyLists && (
        <div style={{ padding: '12px 16px', backgroundColor: 'var(--primary-pale)' }}>
          <button
            onClick={handleAddToMyLists}
            className="w-full flex items-center justify-center gap-2 py-2.5 rounded-lg active:opacity-80"
            style={{
              backgroundColor: 'var(--primary)',
              color: 'white',
              fontSize: '15px',
              fontWeight: 500,
            }}
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
            {t('mobile.addToMyLists')}
          </button>
        </div>
      )}

      {/* Added confirmation */}
      {justAddedToMyLists && (
        <div
          className="flex items-center justify-center gap-2 py-3"
          style={{ backgroundColor: 'var(--primary-pale)' }}
        >
          <svg className="w-5 h-5" style={{ color: 'var(--primary)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
          <span style={{ color: 'var(--primary)', fontWeight: 500 }}>{t('mobile.addedToLists')}</span>
        </div>
      )}

      {/* Main Content */}
      <div className="w-full max-w-lg mx-auto pb-24" style={{ paddingLeft: '8px', paddingRight: '8px' }}>
        <ListContainer
          items={itemTree}
          newItemId={newItemId}
          newItemIds={newItemIds}
          completingItemIds={completingItemIds}
          largeMode={list?.large_mode || false}
          hideInput={true}
          onToggle={toggleItem}
          onUpdate={async (id, content) => {
            await updateItem(id, { content });
          }}
          onDelete={deleteItem}
          onIndent={indentItem}
          onOutdent={outdentItem}
          onReorder={async (activeId, overId) => {
            await reorderItems(activeId, overId);
          }}
          onMoveToGroup={moveToGroup}
          onMoveToRoot={moveToRoot}
          onAddItem={handleAddItem}
          onAddItems={handleAddItems}
          onManipulateList={handleManipulateList}
          onCategorizedGenerate={handleCategorizedGenerate}
          onThemeGenerate={handleThemeGenerate}
          onThemeReset={list?.theme ? handleThemeReset : undefined}
          onCompleteAll={completeAll}
          onUncompleteAll={uncompleteAll}
          onSetLargeMode={updateLargeMode}
          onClearCompleted={clearCompleted}
          onSort={sortItems}
          onUngroupAll={ungroupAll}
          onToggleEmojify={toggleEmojifyMode}
          onNuke={nukeItems}
          onGenerateTitle={handleGenerateTitle}
          prefillValue={inputPrefillValue}
          onPrefillConsumed={() => setInputPrefillValue(undefined)}
        />

      </div>
      </div>

      {/* Dictate Button */}
      <DictateButton onTranscription={handleDictation} />
    </div>
  );
}
