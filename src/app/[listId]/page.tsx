'use client';

import { useParams } from 'next/navigation';
import { useEffect, useState, useCallback, useRef } from 'react';
import { useList } from '@/lib/hooks/useList';
import { useAI, ManipulatedItem } from '@/lib/hooks/useAI';
import { supabase } from '@/lib/supabase';
import { ListTitle } from '@/components/ListTitle';
import { ListContainer } from '@/components/ListContainer';
import { DictateButton } from '@/components/DictateButton';
import { isCategorizedResult } from '@/lib/hooks/useAI';
import { ThemeColors } from '@/lib/gemini';

export default function ListPage() {
  const params = useParams();
  const listId = params.listId as string;
  const [copied, setCopied] = useState(false);
  const [copiedMarkdown, setCopiedMarkdown] = useState(false);
  const [showShareView, setShowShareView] = useState(false);
  const [isTitleAutoGenerated, setIsTitleAutoGenerated] = useState(false);
  const [showBookmarkReminder, setShowBookmarkReminder] = useState(false);
  const [showStyleReminder, setShowStyleReminder] = useState(false);
  const [inputPrefillValue, setInputPrefillValue] = useState<string | undefined>(undefined);
  const autoTitleTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const hasAutoGeneratedRef = useRef(false);
  const hasShownBookmarkReminderRef = useRef(false);
  const hasShownStyleReminderRef = useRef(false);

  const {
    list,
    items,
    itemTree,
    loading,
    error,
    newItemId,
    newItemIds,
    completingItemIds,
    createList,
    updateTitle,
    updateTheme,
    updateLargeMode,
    addItem,
    addItems,
    updateItem,
    toggleItem,
    deleteItem,
    reorderItems,
    moveToGroup,
    moveToRoot,
    indentItem,
    outdentItem,
    completeAll,
    uncompleteAll,
    clearCompleted,
    sortItems,
    ungroupAll,
    nukeItems,
    toggleEmojifyMode,
  } = useList(listId);

  const { manipulateList, generateItems } = useAI();

  // Create list if it doesn't exist (for direct URL access)
  useEffect(() => {
    if (!loading && !list && !error) {
      createList();
    }
  }, [loading, list, error, createList]);

  // Show bookmark reminder for newly created lists
  useEffect(() => {
    if (list && !hasShownBookmarkReminderRef.current) {
      // Check if list was created within the last 30 seconds
      const createdAt = new Date(list.created_at).getTime();
      const now = Date.now();
      const isNewList = now - createdAt < 30000; // 30 seconds

      if (isNewList) {
        hasShownBookmarkReminderRef.current = true;

        // Auto-copy URL to clipboard
        navigator.clipboard.writeText(window.location.href).catch(() => {
          // Clipboard API might fail silently on some browsers
        });

        // Show the reminders
        setShowBookmarkReminder(true);
        setShowStyleReminder(true);
        hasShownStyleReminderRef.current = true;

        // Hide after 2 minutes
        const timeout = setTimeout(() => {
          setShowBookmarkReminder(false);
          setShowStyleReminder(false);
        }, 120000); // 2 minutes

        return () => clearTimeout(timeout);
      }
    }
  }, [list]);

  // Auto-generate title after 3+ items with 2-second debounce
  useEffect(() => {
    // Clear any existing timeout
    if (autoTitleTimeoutRef.current) {
      clearTimeout(autoTitleTimeoutRef.current);
    }

    // Only trigger if:
    // 1. List exists and has no title
    // 2. Has 3 or more non-header items
    // 3. Haven't already auto-generated a title this session
    const nonHeaderItems = items.filter(item => !item.content.startsWith('#'));
    const shouldAutoGenerate =
      list &&
      !list.title &&
      nonHeaderItems.length >= 3 &&
      !hasAutoGeneratedRef.current;

    if (shouldAutoGenerate) {
      autoTitleTimeoutRef.current = setTimeout(async () => {
        try {
          const itemContents = items
            .filter(item => !item.completed && !item.content.startsWith('#'))
            .map(item => item.content);

          if (itemContents.length === 0) return;

          const response = await fetch('/api/title', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ items: itemContents }),
          });

          if (response.ok) {
            const { title } = await response.json();
            // Only update if title is still null (user hasn't set one manually)
            if (!list.title) {
              hasAutoGeneratedRef.current = true;
              setIsTitleAutoGenerated(true);
              await updateTitle(title);
              // Reset the auto-generated flag after animation
              setTimeout(() => setIsTitleAutoGenerated(false), 1500);
            }
          }
        } catch (err) {
          console.error('Auto-title generation failed:', err);
        }
      }, 2000); // 2-second debounce
    }

    return () => {
      if (autoTitleTimeoutRef.current) {
        clearTimeout(autoTitleTimeoutRef.current);
      }
    };
  }, [items, list, updateTitle]);

  // Apply theme from list data
  const applyTheme = useCallback((theme: ThemeColors | null) => {
    const root = document.documentElement;
    if (theme) {
      root.style.setProperty('--primary', theme.primary);
      root.style.setProperty('--primary-dark', theme.primaryDark);
      root.style.setProperty('--primary-light', theme.primaryLight);
      root.style.setProperty('--primary-pale', theme.primaryPale);
      root.style.setProperty('--primary-glow', theme.primaryGlow);
      root.style.setProperty('--text-primary', theme.textPrimary);
      root.style.setProperty('--text-secondary', theme.textSecondary);
      root.style.setProperty('--text-muted', theme.textMuted);
      root.style.setProperty('--text-placeholder', theme.textPlaceholder);
      root.style.setProperty('--bg-primary', theme.bgPrimary);
      root.style.setProperty('--bg-secondary', theme.bgSecondary);
      root.style.setProperty('--bg-hover', theme.bgHover);
      root.style.setProperty('--border-light', theme.borderLight);
      root.style.setProperty('--border-medium', theme.borderMedium);
      root.style.setProperty('--error', theme.error);
    } else {
      // Reset to defaults
      root.style.removeProperty('--primary');
      root.style.removeProperty('--primary-dark');
      root.style.removeProperty('--primary-light');
      root.style.removeProperty('--primary-pale');
      root.style.removeProperty('--primary-glow');
      root.style.removeProperty('--text-primary');
      root.style.removeProperty('--text-secondary');
      root.style.removeProperty('--text-muted');
      root.style.removeProperty('--text-placeholder');
      root.style.removeProperty('--bg-primary');
      root.style.removeProperty('--bg-secondary');
      root.style.removeProperty('--bg-hover');
      root.style.removeProperty('--border-light');
      root.style.removeProperty('--border-medium');
      root.style.removeProperty('--error');
    }
  }, []);

  // Apply theme when list loads
  useEffect(() => {
    if (list) {
      applyTheme(list.theme);
    }
    // Cleanup: reset theme when leaving the page
    return () => {
      applyTheme(null);
    };
  }, [list, applyTheme]);

  // Handle theme generation
  const handleThemeGenerate = async (description: string) => {
    const response = await fetch('/api/theme', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ description }),
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Theme generation failed');
    }

    const { theme } = await response.json();

    // Apply theme immediately
    applyTheme(theme);

    // Save to database
    await updateTheme(theme);
  };

  // Handle theme reset
  const handleThemeReset = async () => {
    applyTheme(null);
    await updateTheme(null);
  };

  // Helper to emojify text
  const emojifyText = async (text: string): Promise<string> => {
    try {
      const response = await fetch('/api/emojify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });
      if (response.ok) {
        const { emoji } = await response.json();
        return `${emoji} ${text}`;
      }
    } catch (err) {
      console.error('Emojify failed:', err);
    }
    return text; // Return original if emojify fails
  };

  // Wrapper for addItem that handles emojify
  const handleAddItem = async (content: string, parentId?: string | null) => {
    let finalContent = content;
    // Only emojify regular items (not headers starting with #)
    if (list?.emojify_mode && !content.startsWith('#') && !content.startsWith('--')) {
      finalContent = await emojifyText(content);
    }
    await addItem(finalContent, parentId);
  };

  // Wrapper for addItems that handles emojify
  const handleAddItems = async (contents: string[], parentId?: string | null) => {
    let finalContents = contents;
    if (list?.emojify_mode) {
      // Emojify all items in parallel
      finalContents = await Promise.all(
        contents.map(async (content) => {
          if (!content.startsWith('#') && !content.startsWith('--')) {
            return await emojifyText(content);
          }
          return content;
        })
      );
    }
    return await addItems(finalContents, parentId);
  };

  const handleShareClick = () => {
    setShowShareView(true);
  };

  const handleCopyUrl = async () => {
    await navigator.clipboard.writeText(window.location.href);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleCopyMarkdown = async () => {
    // Convert list to Markdown format
    const title = list?.title || 'Untitled List';
    let markdown = `# ${title}\n\n`;

    // Group items by parent
    const rootItems = items.filter(item => !item.parent_id);
    const childrenByParent: Record<string, typeof items> = {};
    items.forEach(item => {
      if (item.parent_id) {
        if (!childrenByParent[item.parent_id]) {
          childrenByParent[item.parent_id] = [];
        }
        childrenByParent[item.parent_id].push(item);
      }
    });

    rootItems.forEach(item => {
      if (item.content.startsWith('#')) {
        // Header/category
        markdown += `## ${item.content.slice(1).trim()}\n`;
        const children = childrenByParent[item.id] || [];
        children.forEach(child => {
          const checkbox = child.completed ? '[x]' : '[ ]';
          markdown += `- ${checkbox} ${child.content}\n`;
        });
        markdown += '\n';
      } else {
        // Regular item
        const checkbox = item.completed ? '[x]' : '[ ]';
        markdown += `- ${checkbox} ${item.content}\n`;
      }
    });

    await navigator.clipboard.writeText(markdown.trim());
    setCopiedMarkdown(true);
    setTimeout(() => setCopiedMarkdown(false), 2000);
  };

  const handleBackToList = () => {
    setShowShareView(false);
    setCopied(false);
    setCopiedMarkdown(false);
  };

  // Handle Escape key to close share view
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && showShareView) {
        handleBackToList();
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [showShareView]);

  // Generate title from items
  const handleGenerateTitle = async () => {
    const itemContents = items
      .filter(item => !item.completed && !item.content.startsWith('#'))
      .map(item => item.content);

    if (itemContents.length === 0) return;

    try {
      const response = await fetch('/api/title', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items: itemContents }),
      });

      if (response.ok) {
        const { title } = await response.json();
        await updateTitle(title);
      }
    } catch (err) {
      console.error('Title generation failed:', err);
    }
  };

  const handleManipulateList = async (instruction: string) => {
    // Get only incomplete items for manipulation
    const incompleteItems = items.filter(item => !item.completed);

    if (incompleteItems.length === 0) {
      throw new Error('No items to reorganize');
    }

    // Send to AI for manipulation
    const manipulatedItems = await manipulateList(incompleteItems, instruction);

    // Separate new items (headers) from existing items
    const newItems = manipulatedItems.filter(item => item.id.startsWith('new_'));
    const existingItems = manipulatedItems.filter(item => !item.id.startsWith('new_'));

    // Create a mapping from placeholder IDs to real IDs
    const idMapping: Record<string, string> = {};

    // Create new header items in database
    for (const newItem of newItems) {
      const { data, error } = await supabase
        .from('items')
        .insert({
          list_id: listId,
          content: newItem.content,
          completed: false,
          parent_id: null,
          position: newItem.position,
        })
        .select()
        .single();

      if (error) throw error;
      if (data) {
        idMapping[newItem.id] = data.id;
      }
    }

    // Update existing items with new positions and parent_ids
    for (const manipulatedItem of existingItems) {
      // Translate parent_id from placeholder to real ID
      let realParentId = manipulatedItem.parent_id;
      if (realParentId && idMapping[realParentId]) {
        realParentId = idMapping[realParentId];
      }

      await updateItem(manipulatedItem.id, {
        content: manipulatedItem.content,
        position: manipulatedItem.position,
        parent_id: realParentId,
      });
    }
  };

  // Handle dictation transcription - send to Gemini for list generation
  const handleDictation = async (transcription: string) => {
    if (!transcription.trim()) return;

    try {
      const result = await generateItems(transcription);

      if (result.length > 0) {
        if (isCategorizedResult(result)) {
          await handleCategorizedGenerate(result);
        } else {
          // Simple string array - use bulk add
          await addItems(result);
        }
      }
    } catch (err) {
      console.error('Failed to process dictation:', err);
    }
  };

  // Handle AI-generated categorized items (all items are new)
  const handleCategorizedGenerate = async (generatedItems: ManipulatedItem[]) => {
    if (generatedItems.length === 0) return;

    // Create a mapping from placeholder IDs to real IDs
    const idMapping: Record<string, string> = {};

    // First pass: create all headers (items without parent_id)
    const headers = generatedItems.filter(item => !item.parent_id);
    for (const header of headers) {
      const { data, error } = await supabase
        .from('items')
        .insert({
          list_id: listId,
          content: header.content,
          completed: false,
          parent_id: null,
          position: header.position,
        })
        .select()
        .single();

      if (error) throw error;
      if (data) {
        idMapping[header.id] = data.id;
      }
    }

    // Second pass: create child items with translated parent_ids
    const children = generatedItems.filter(item => item.parent_id);
    for (const child of children) {
      // Translate parent_id from placeholder to real ID
      const realParentId = child.parent_id ? idMapping[child.parent_id] : null;

      const { data, error } = await supabase
        .from('items')
        .insert({
          list_id: listId,
          content: child.content,
          completed: false,
          parent_id: realParentId,
          position: child.position,
        })
        .select()
        .single();

      if (error) throw error;
      if (data) {
        idMapping[child.id] = data.id;
      }
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: 'var(--bg-primary)' }}>
        <div className="text-[var(--primary)] animate-pulse">Loading...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: 'var(--bg-primary)' }}>
        <div style={{ color: 'var(--error)' }}>{error}</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col items-center" style={{ backgroundColor: 'var(--bg-primary)' }}>
      {/* Centered content container */}
      <div className="w-full max-w-lg pb-16" style={{ paddingTop: '32px', paddingLeft: '8px', paddingRight: '8px' }}>
        {/* Header */}
        <div className="mb-6 flex items-center justify-between">
          <ListTitle title={list?.title || null} onUpdate={updateTitle} isAutoGenerated={isTitleAutoGenerated} />
          {showShareView ? (
            <button
              onClick={handleBackToList}
              className="text-sm py-1.5 transition-all duration-200 flex items-center gap-1.5 hover:text-[var(--primary)] hover:bg-[var(--primary-pale)]"
              style={{
                paddingLeft: '4px',
                paddingRight: '4px',
                borderRadius: '2px',
                color: 'var(--text-muted)'
              }}
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
              </svg>
              Back to list
            </button>
          ) : (
            <button
              onClick={handleShareClick}
              className="text-sm py-1.5 transition-all duration-200 flex items-center gap-1.5 hover:text-[var(--primary)] hover:bg-[var(--primary-pale)]"
              style={{
                paddingLeft: '4px',
                paddingRight: '4px',
                borderRadius: '2px',
                color: 'var(--text-muted)'
              }}
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
              </svg>
              Share
            </button>
          )}
        </div>

        {/* Share View */}
        {showShareView ? (
          <div style={{ paddingTop: '16px' }}>
            {/* Collaboration explainer */}
            <div
              className="text-sm px-4"
              style={{ color: 'var(--text-muted)', marginBottom: '16px' }}
            >
              Anyone with this link can view and edit the list in real-time.
            </div>

            {/* Share options - styled like list items */}
            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
              {/* Copy URL */}
              <button
                onClick={handleCopyUrl}
                className="w-full flex items-center gap-3 py-3 px-4 rounded transition-all duration-150"
                style={{
                  backgroundColor: copied ? 'var(--primary-pale)' : 'transparent',
                }}
                onMouseEnter={(e) => { if (!copied) e.currentTarget.style.backgroundColor = 'var(--primary-pale)'; }}
                onMouseLeave={(e) => { if (!copied) e.currentTarget.style.backgroundColor = 'transparent'; }}
              >
                {copied ? (
                  <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--primary)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                ) : (
                  <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--text-muted)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                  </svg>
                )}
                <span style={{ color: copied ? 'var(--primary)' : 'var(--text-primary)' }}>
                  {copied ? 'Link copied!' : 'Copy link'}
                </span>
              </button>

              {/* Copy as Markdown */}
              <button
                onClick={handleCopyMarkdown}
                className="w-full flex items-center gap-3 py-3 px-4 rounded transition-all duration-150"
                style={{
                  backgroundColor: copiedMarkdown ? 'var(--primary-pale)' : 'transparent',
                }}
                onMouseEnter={(e) => { if (!copiedMarkdown) e.currentTarget.style.backgroundColor = 'var(--primary-pale)'; }}
                onMouseLeave={(e) => { if (!copiedMarkdown) e.currentTarget.style.backgroundColor = 'transparent'; }}
              >
                {copiedMarkdown ? (
                  <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--primary)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                ) : (
                  <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--text-muted)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                  </svg>
                )}
                <span style={{ color: copiedMarkdown ? 'var(--primary)' : 'var(--text-primary)' }}>
                  {copiedMarkdown ? 'Markdown copied!' : 'Copy as Markdown'}
                </span>
              </button>

              {/* Send via Email */}
              <a
                href={(() => {
                  const title = list?.title || 'Untitled List';
                  const subject = encodeURIComponent(`Here's a checklist for you: ${title}`);
                  const body = encodeURIComponent(`${title}\n\n${typeof window !== 'undefined' ? window.location.href : ''}`);
                  return `mailto:?subject=${subject}&body=${body}`;
                })()}
                className="w-full flex items-center gap-3 py-3 px-4 rounded transition-all duration-150"
                style={{ backgroundColor: 'transparent' }}
                onMouseEnter={(e) => { e.currentTarget.style.backgroundColor = 'var(--primary-pale)'; }}
                onMouseLeave={(e) => { e.currentTarget.style.backgroundColor = 'transparent'; }}
              >
                <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--text-muted)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                </svg>
                <span style={{ color: 'var(--text-primary)' }}>
                  Send via email
                </span>
              </a>
            </div>

            {/* Future integrations placeholder */}
            <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid var(--border-light)' }}>
              <div className="text-sm px-4" style={{ color: 'var(--text-muted)' }}>
                More sharing options coming soon
              </div>
            </div>
          </div>
        ) : (
          /* List */
          <ListContainer
            items={itemTree}
            newItemId={newItemId}
            newItemIds={newItemIds}
            completingItemIds={completingItemIds}
            largeMode={list?.large_mode || false}
            onToggle={toggleItem}
            onUpdate={async (id, content) => {
              await updateItem(id, { content });
            }}
            onDelete={deleteItem}
            onIndent={indentItem}
            onOutdent={outdentItem}
            onReorder={async (activeId, overId) => {
              await reorderItems(activeId, overId);
            }}
            onMoveToGroup={moveToGroup}
            onMoveToRoot={moveToRoot}
            onAddItem={handleAddItem}
            onAddItems={handleAddItems}
            onManipulateList={handleManipulateList}
            onCategorizedGenerate={handleCategorizedGenerate}
            onThemeGenerate={handleThemeGenerate}
            onThemeReset={list?.theme ? handleThemeReset : undefined}
            onCompleteAll={completeAll}
            onUncompleteAll={uncompleteAll}
            onSetLargeMode={updateLargeMode}
            onClearCompleted={clearCompleted}
            onSort={sortItems}
            onUngroupAll={ungroupAll}
            onToggleEmojify={toggleEmojifyMode}
            onNuke={nukeItems}
            onGenerateTitle={handleGenerateTitle}
            hideBottomPadding={showBookmarkReminder || showStyleReminder}
            prefillValue={inputPrefillValue}
            onPrefillConsumed={() => setInputPrefillValue(undefined)}
          />
        )}

        {/* Bookmark reminder for new lists - styled exactly like a list item */}
        {showBookmarkReminder && !showShareView && (
          <div
            className="flex items-center gap-3 rounded-lg group item-hover cursor-pointer"
            style={{ marginBottom: showStyleReminder ? '4px' : '80px' }}
            onClick={() => {
              setShowBookmarkReminder(false);
              setShowShareView(true);
            }}
          >
            <div
              className="flex items-center gap-3 flex-1"
              style={{ paddingTop: '2px', paddingBottom: '2px' }}
            >
              {/* Spacer matching drag handle width */}
              <div className="w-4 h-4" />

              {/* Interactive checkbox - same as task items */}
              <button
                onClick={(e) => {
                  e.stopPropagation(); // Prevent opening share view
                  // Create sparkle effect
                  const button = document.getElementById('bookmark-reminder-checkbox');
                  if (button) {
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    for (let i = 0; i < 8; i++) {
                      const particle = document.createElement('div');
                      particle.className = 'sparkle-particle';
                      const angle = (i / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                      const distance = 20 + Math.random() * 15;
                      const tx = Math.cos(angle) * distance;
                      const ty = Math.sin(angle) * distance - 10;
                      particle.style.left = `${centerX}px`;
                      particle.style.top = `${centerY}px`;
                      particle.style.setProperty('--tx', `${tx}px`);
                      particle.style.setProperty('--ty', `${ty}px`);
                      button.appendChild(particle);
                      setTimeout(() => particle.remove(), 600);
                    }
                  }
                  // Dismiss after animation
                  setTimeout(() => setShowBookmarkReminder(false), 400);
                }}
                id="bookmark-reminder-checkbox"
                className="relative w-5 h-5 rounded-md border-2 flex items-center justify-center checkbox transition-all duration-150 hover:border-[var(--primary)]"
                style={{ borderColor: 'var(--border-medium)' }}
              />

              {/* Text - same styling as item text */}
              <span style={{ color: 'var(--text-primary)' }}>
                ü§ì Link copied to clipboard. Don't lose your list, save it!
              </span>
            </div>
          </div>
        )}

        {/* Style reminder for new lists */}
        {showStyleReminder && !showShareView && (
          <div
            className="flex items-center gap-3 rounded-lg group item-hover cursor-pointer"
            style={{ marginBottom: '80px' }}
            onClick={() => {
              setShowStyleReminder(false);
              setInputPrefillValue('style: ');
            }}
          >
            <div
              className="flex items-center gap-3 flex-1"
              style={{ paddingTop: '2px', paddingBottom: '2px' }}
            >
              {/* Spacer matching drag handle width */}
              <div className="w-4 h-4" />

              {/* Interactive checkbox - same as task items */}
              <button
                onClick={(e) => {
                  e.stopPropagation(); // Prevent prefilling input
                  // Create sparkle effect
                  const button = document.getElementById('style-reminder-checkbox');
                  if (button) {
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    for (let i = 0; i < 8; i++) {
                      const particle = document.createElement('div');
                      particle.className = 'sparkle-particle';
                      const angle = (i / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                      const distance = 20 + Math.random() * 15;
                      const tx = Math.cos(angle) * distance;
                      const ty = Math.sin(angle) * distance - 10;
                      particle.style.left = `${centerX}px`;
                      particle.style.top = `${centerY}px`;
                      particle.style.setProperty('--tx', `${tx}px`);
                      particle.style.setProperty('--ty', `${ty}px`);
                      button.appendChild(particle);
                      setTimeout(() => particle.remove(), 600);
                    }
                  }
                  // Dismiss after animation
                  setTimeout(() => setShowStyleReminder(false), 400);
                }}
                id="style-reminder-checkbox"
                className="relative w-5 h-5 rounded-md border-2 flex items-center justify-center checkbox transition-all duration-150 hover:border-[var(--primary)]"
                style={{ borderColor: 'var(--border-medium)' }}
              />

              {/* Text - same styling as item text */}
              <span style={{ color: 'var(--text-primary)' }}>
                üñåÔ∏è Write style: + describe to customize your list
              </span>
            </div>
          </div>
        )}

        {/* Reference section - AI Features & Commands (hide when sharing) */}
        {!showShareView && (
          <div className="mt-8 mb-8">
            {/* Subtle divider */}
            <div
              style={{
                height: '1px',
                backgroundColor: 'var(--border-light)',
                opacity: 0.5,
              }}
            />

            <div
              className="text-xs"
              style={{ color: 'var(--text-muted)', paddingTop: '16px' }}
            >
              {/* AI Features */}
              <div style={{ marginBottom: '24px' }}>
                <div className="flex items-center gap-2">
                  <svg className="w-3.5 h-3.5" style={{ color: 'var(--primary)' }} viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0L13.5 8.5L22 10L13.5 11.5L12 20L10.5 11.5L2 10L10.5 8.5L12 0Z" />
                  </svg>
                  <span style={{ fontWeight: 600, color: 'var(--primary)' }}>AI FEATURES</span>
                </div>
                <div style={{ marginBottom: '12px', marginTop: '4px' }}>Start your input with these prefixes</div>
                <div className="space-y-2 pl-5">
                  <div><span style={{ color: 'var(--primary)', fontWeight: 500 }}>!</span> AI list manipulation ¬∑ !categorize list</div>
                  <div><span style={{ color: 'var(--primary)', fontWeight: 500 }}>...</span> Generate items ¬∑ ...camping essentials</div>
                  <div><span style={{ color: 'var(--primary)', fontWeight: 500 }}>style:</span> Custom theme ¬∑ style: ocean sunset</div>
                </div>
              </div>

              {/* Active options */}
              {(list?.large_mode || list?.emojify_mode) && (
                <div style={{ marginBottom: '24px' }}>
                  <div className="flex items-center gap-2" style={{ marginBottom: '12px' }}>
                    <svg className="w-3.5 h-3.5" style={{ color: 'var(--text-secondary)' }} fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    <span style={{ fontWeight: 600, color: 'var(--text-secondary)' }}>ACTIVE</span>
                  </div>
                  <div className="pl-5 space-y-2">
                    {list?.large_mode && (
                      <div>large mode ¬∑ --normal to turn off</div>
                    )}
                    {list?.emojify_mode && (
                      <div>emojify ¬∑ --emojify to toggle off</div>
                    )}
                  </div>
                </div>
              )}

              {/* Commands */}
              <div style={{ paddingBottom: '60px' }}>
                <div className="flex items-center gap-2" style={{ marginBottom: '12px' }}>
                  <svg className="w-3.5 h-3.5" style={{ color: 'var(--text-secondary)' }} fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clipRule="evenodd" />
                  </svg>
                  <span style={{ fontWeight: 600, color: 'var(--text-secondary)' }}>COMMANDS</span>
                </div>
                <div className="pl-5 space-y-2">
                  <div># Create categories ¬∑ # Urgent</div>
                  <div>, (comma) Add multiple items ¬∑ eggs, milk, bread</div>
                  <div style={{ marginTop: '8px' }}>--complete ¬∑ Complete all items</div>
                  <div>--reset ¬∑ Reset all items to incomplete</div>
                  <div>--clean ¬∑ Clean up all completed</div>
                  <div>--large ¬∑ Make everything 2x larger</div>
                  <div>--emojify ¬∑ Add a relevant emoji to new items</div>
                  <div>--sort ¬∑ Sort items alphabetically</div>
                  <div>--sort all ¬∑ Sort all items and groups</div>
                  <div>--ungroup ¬∑ Remove all groups</div>
                  <div>--title ¬∑ Generate list title</div>
                  <div style={{ marginTop: '8px', opacity: 0.6 }}>--nuke ¬∑ Deletes everything</div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Dictate button (hide when sharing) */}
      {!showShareView && <DictateButton onTranscription={handleDictation} />}
    </div>
  );
}
